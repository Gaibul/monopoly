<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Monopoly â€” Firebase Multiplayer (Oneâ€‘File)</title>
<style>
  :root{ --panel:#101624; --panel2:#0b1222; --panelBorder:rgba(255,255,255,.12); --panelText:#e8ecf1; }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 20% 20%, #0d1117, #0b1320 60%, #070a12); color:var(--panelText); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
  .hidden{display:none !important}
  /* Lobby */
  #screenLobby{display:grid;place-items:center;min-height:100vh;padding:24px}
  .lobby{width:min(980px,95vw);background:var(--panel);border:1px solid var(--panelBorder);border-radius:18px;padding:18px;box-shadow:0 25px 60px rgba(0,0,0,.45)}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .big{font-size:22px;font-weight:800}
  .muted{color:#aab3c2;font-size:13px}
  .hr{height:1px;background:linear-gradient(90deg,transparent, rgba(255,255,255,.18), transparent);margin:12px 0}
  .pill{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.2);padding:10px 14px;border-radius:999px;cursor:pointer;user-select:none;color:#e8ecf1;font-weight:600;letter-spacing:.2px}
  .pill[disabled]{opacity:.4;cursor:not-allowed}
  .inp{width:100%;padding:10px;border-radius:10px;border:1px solid var(--panelBorder);background:#0e1424;color:#fff}
  .tabs{display:flex;gap:8px;margin-top:8px}
  .tab{padding:8px 12px;border-radius:999px;border:1px solid var(--panelBorder);cursor:pointer}
  .tab.active{background:#162037}
  .colors{display:grid;grid-template-columns:repeat(8, 1fr);gap:8px;margin-top:6px}
  .swatch{height:34px;border-radius:10px;border:1px solid rgba(255,255,255,.25);cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700}
  .swatch.taken{filter:grayscale(1) brightness(.6);cursor:not-allowed}
  .swatch.selected{outline:2px solid #fff; outline-offset:2px}
  .plist{display:grid;grid-template-columns:1fr auto;gap:6px;margin-top:8px}
  .roomCode{font-size:22px;font-weight:800;letter-spacing:3px}

  /* Game */
  #screenGame{display:grid;height:100vh}
  #wrap{display:grid;grid-template-columns:minmax(760px,1fr) 380px; gap:16px; height:100%}
  #game{width:100%;height:100%;display:block;}
  #ui{display:flex;flex-direction:column;gap:12px;padding:12px;background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));border-left:1px solid var(--panelBorder)}
  .card{background:var(--panel2);border:1px solid var(--panelBorder);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:12px}
  .mono{font-variant-numeric:tabular-nums}
  #log{height:260px;overflow:auto;font-size:13px;line-height:1.35;background:#0f1327;border:1px solid rgba(255,255,255,.06);border-radius:10px;padding:8px}
  .money{font-weight:700}

  /* Modals */
  #card{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:25}
  #card .paper{background:#fff;border-radius:14px;width:360px;max-width:90vw;box-shadow:0 18px 60px rgba(0,0,0,.45);overflow:hidden}
  #cardHead{padding:12px 14px;font-weight:800;color:#111;text-align:center;background:#ffd166}
  #cardBody{padding:16px 14px 18px 14px;color:#111;min-height:100px;text-align:center;font-size:16px;line-height:1.32}
</style>
</head>
<body>

<!-- ===== LOBBY ===== -->
<section id="screenLobby">
  <div class="lobby">
    <div class="row" style="justify-content:space-between;align-items:end">
      <div>
        <div class="big">Monopoly â€” Online</div>
        <div class="muted">Host or join a room. Host starts; turns rotate clockwise. Max 16 players. Unique colours.</div>
      </div>
      <div class="row"><span class="muted">Status:</span><span id="status">offline</span></div>
    </div>
    <div class="hr"></div>

    <div class="tabs">
      <button id="tabHost" class="tab active">Host</button>
      <button id="tabJoin" class="tab">Join</button>
    </div>

    <div id="hostPane">
      <div class="row" style="gap:12px;margin-top:10px">
        <input id="hostName" class="inp" placeholder="Your name" style="flex:2">
        <input id="hostMax" class="inp" type="number" min="2" max="16" value="6" style="width:140px">
      </div>
      <div style="margin-top:8px">Pick a colour</div>
      <div class="colors" id="hostColors"></div>
      <div class="row" style="margin-top:10px">
        <button id="btnCreate" class="pill">Create Room</button>
        <div id="createError" class="muted"></div>
      </div>
      <div id="hostRoomInfo" class="row hidden" style="margin-top:10px">
        <div>Room Code:</div>
        <div class="roomCode" id="roomCodeHost">â€”</div>
        <button id="btnStart" class="pill" disabled>Start Game</button>
      </div>
    </div>

    <div id="joinPane" class="hidden">
      <div class="row" style="gap:12px;margin-top:10px">
        <input id="joinName" class="inp" placeholder="Your name" style="flex:2">
        <input id="joinCode" class="inp" placeholder="ROOM" style="width:160px;text-transform:uppercase">
      </div>
      <div style="margin-top:8px">Pick a colour</div>
      <div class="colors" id="joinColors"></div>
      <div class="row" style="margin-top:10px">
        <button id="btnJoin" class="pill">Join Room</button>
        <div id="joinError" class="muted"></div>
      </div>
    </div>

    <div class="hr"></div>
    <div>
      <div class="big">Players in Room</div>
      <div id="lobbyPlayers" class="plist"></div>
    </div>
  </div>
</section>

<!-- ===== GAME ===== -->
<section id="screenGame" class="hidden">
  <div id="wrap">
    <canvas id="game" width="1100" height="1100"></canvas>
    <div id="ui">
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div class="big">Monopoly â€” Canvas</div>
          <div class="row mono" id="diceFace">ðŸŽ² â€”</div>
        </div>
        <div class="row" style="margin-top:8px; gap:8px">
          <button id="btnRoll" class="pill" disabled>Roll Dice</button>
          <button id="btnBuy" class="pill" disabled>Buy</button>
          <button id="btnEnd" class="pill" disabled>End Turn</button>
        </div>
        <div class="hr"></div>
        <div class="row" style="justify-content:space-between">
          <div>Turn</div><div id="turnName" class="mono"></div>
        </div>
      </div>

      <div class="card">
        <div class="big">Players</div>
        <div id="players" class="plist"></div>
      </div>

      <div class="card">
        <div class="big">Activity</div>
        <div id="log"></div>
      </div>
    </div>
  </div>
</section>

<!-- Card Modal (deeds / chance / chest) -->
<div id="card">
  <div class="paper">
    <div id="cardHead">Card</div>
    <div id="cardBody"></div>
    <div style="display:flex;justify-content:center;padding:10px 0 16px 0"><button id="cardOk" class="pill" style="color:#111;background:#ffd166;border-color:#e8b941">OK</button></div>
  </div>
</div>

<script type="module">
// ==============================
// Firebase setup
// ==============================
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, serverTimestamp, child, runTransaction } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAEqutXCO5OZD6VU_ohaBxNfh7G8Q6PEy0",
  authDomain: "nomercy-8269a.firebaseapp.com",
  databaseURL: "https://nomercy-8269a-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "nomercy-8269a",
  storageBucket: "nomercy-8269a.firebasestorage.app",
  messagingSenderId: "349047620790",
  appId: "1:349047620790:web:3206ff81cb7f5413d29217",
  measurementId: "G-1WX7CWBFGF"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// ==============================
// DOM helpers & constants
// ==============================
const $ = sel => document.querySelector(sel);
const statusEl = $('#status');
const logEl = $('#log');
function log(msg){ const atBottom = Math.abs(logEl.scrollHeight - (logEl.scrollTop + logEl.clientHeight)) < 6; const div = document.createElement('div'); div.innerHTML = msg; logEl.appendChild(div); if(atBottom) logEl.scrollTop = logEl.scrollHeight; }

const COLORS = [
  '#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#22c55e','#10b981','#14b8a6',
  '#06b6d4','#0ea5e9','#3b82f6','#6366f1','#8b5cf6','#a855f7','#ec4899','#f43f5e'
];

let me = { playerId:null, name:null, color:null, room:null, isHost:false };

// Tabs
$('#tabHost').onclick = ()=>{ $('#tabHost').classList.add('active'); $('#tabJoin').classList.remove('active'); $('#hostPane').classList.remove('hidden'); $('#joinPane').classList.add('hidden'); };
$('#tabJoin').onclick = ()=>{ $('#tabJoin').classList.add('active'); $('#tabHost').classList.remove('active'); $('#joinPane').classList.remove('hidden'); $('#hostPane').classList.add('hidden'); };

// Build colour swatches
function renderColorGrid(el, selectedColor, takenSet){ el.innerHTML=''; COLORS.forEach((c)=>{ const b=document.createElement('button'); b.className='swatch'; b.style.background=c; b.dataset.color=c; if(takenSet && takenSet.has(c)) b.classList.add('taken'); if(selectedColor===c) b.classList.add('selected'); b.onclick=()=>{ if(b.classList.contains('taken')) return; [...el.querySelectorAll('.swatch')].forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); el.dataset.value=c; }; el.appendChild(b); }); }
renderColorGrid($('#hostColors'));
renderColorGrid($('#joinColors'));

// Generate a 4â€‘letter room code
function roomCode(){ const A='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<4;i++) s+=A[Math.random()*A.length|0]; return s; }

// Persist identity for rejoin â€” DISABLED per user request
function remember(){ /* persistence disabled */ }
function recall(){ return null; }

// Observe players in lobby
let currentRoomRef=null; let playersUnsub=null; let lobbyStateUnsub=null;
async function bindLobby(room){ if(playersUnsub) playersUnsub(); if(lobbyStateUnsub) lobbyStateUnsub(); const r=ref(db, `rooms/${room}`); currentRoomRef=r; playersUnsub = onValue(child(r,'players'), snap=>{ const data=snap.val()||{}; const list=$('#lobbyPlayers'); list.innerHTML=''; const taken = new Set(Object.values(data).map(p=>p.color)); renderColorGrid($('#hostColors'), $('#hostColors').dataset.value, taken); renderColorGrid($('#joinColors'), $('#joinColors').dataset.value, taken);
  Object.entries(data).forEach(([pid,p])=>{ const n1=document.createElement('div'); const n2=document.createElement('div'); n1.textContent=p.name + (p.disconnected?' (reconnectingâ€¦)':''); n2.textContent=`$${p.cash??1500}`; n2.className='mono money'; const dot=document.createElement('span'); dot.style.width='10px'; dot.style.height='10px'; dot.style.borderRadius='999px'; dot.style.display='inline-block'; dot.style.background=p.color; n1.prepend(dot); list.append(n1,n2); });
  // Host can start when >=2 players and all with colors
  get(child(r,'meta')).then(ms=>{ const m=ms.val()||{}; const count=Object.keys(data).length; const okColors=Object.values(data).every(p=>!!p.color && !!p.name); if(me.isHost && m.state==='lobby') $('#btnStart').disabled = !(count>=2 && okColors); });
});
  lobbyStateUnsub = onValue(child(r,'meta'), snap=>{ const m=snap.val()||{}; if(m.state==='playing'){ // go to game
      startGameUI(room);
    }
  });
}

// Host: create room
$('#btnCreate').onclick = async ()=>{
  const name=$('#hostName').value.trim(); const max=parseInt($('#hostMax').value||'6',10); const color=$('#hostColors').dataset.value||null; if(!name){ $('#createError').textContent='Enter a name.'; return; } if(!color){ $('#createError').textContent='Pick a colour.'; return; }
  const code = roomCode(); const r=ref(db, `rooms/${code}`);
  const playerId = crypto.randomUUID();
  const meta={ hostId:playerId, maxPlayers: Math.max(2, Math.min(16, max)), state:'lobby', createdAt: serverTimestamp() };
  const player={ name, color, cash:1500, pos:0, inJail:false, jailTurns:0, goojf:0 };
  await set(r, { meta, players: { [playerId]: player } });
  me={ playerId, name, color, room:code, isHost:true }; remember();
  statusEl.textContent = `room ${code}`; $('#roomCodeHost').textContent=code; $('#hostRoomInfo').classList.remove('hidden');
  await bindLobby(code);
};

// Join: join room
$('#btnJoin').onclick = async ()=>{
  const name=$('#joinName').value.trim(); const code=($('#joinCode').value||'').trim().toUpperCase(); const color=$('#joinColors').dataset.value||null; if(!name){ $('#joinError').textContent='Enter a name.'; return; } if(!code){ $('#joinError').textContent='Enter a room code.'; return; } if(!color){ $('#joinError').textContent='Pick a colour.'; return; }
  const r=ref(db, `rooms/${code}`); const snap=await get(r); if(!snap.exists()){ $('#joinError').textContent='Room not found.'; return; }
  const meta=(await get(child(r,'meta'))).val(); if(meta.state!=='lobby'){ $('#joinError').textContent='Game already started.'; return; }
  const players=(await get(child(r,'players'))).val()||{}; if(Object.values(players).some(p=>p.color===color)){ $('#joinError').textContent='Colour already taken.'; return; }
  const playerId = crypto.randomUUID();
  await update(r, { [`players/${playerId}`]: { name, color, cash:1500, pos:0, inJail:false, jailTurns:0, goojf:0 } });
  me={ playerId, name, color, room:code, isHost:false }; remember();
  statusEl.textContent = `room ${code}`;
  await bindLobby(code);
};

// Rejoin disabled â€” always start fresh in this tab

// ==============================
// Game constants / tiles
// ==============================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const SIZE = Math.min(canvas.width, canvas.height); const M=20; let CORNER=170; let EDGE=(SIZE-2*M-2*CORNER)/9;
const BOARD_URL = 'https://upload.wikimedia.org/wikipedia/commons/9/92/Monopoly-board.jpg';
let boardImg = new Image(); let boardReady=false; boardImg.crossOrigin='anonymous'; boardImg.onload=()=>{ boardReady=true; const W=SIZE-2*M; const ring=Math.round(W/11); CORNER=ring; EDGE=(W-2*CORNER)/9; drawBoard(); }; boardImg.src=BOARD_URL;

const T = { GO:'go', PROPERTY:'property', RAILROAD:'railroad', UTILITY:'utility', TAX:'tax', CHANCE:'chance', CHEST:'chest', JAIL:'jail', GOTOJAIL:'gotojail', PARK:'park' };
const tiles=[
  {i:0,type:T.GO,name:'GO'},
  {i:1,type:T.PROPERTY,name:'Old Kent Road',group:'brown',color:'brown',price:60,rent:[2,10,30,90,160,250],houseCost:50},
  {i:2,type:T.CHEST,name:'Community Chest'},
  {i:3,type:T.PROPERTY,name:'Whitechapel Road',group:'brown',color:'brown',price:60,rent:[4,20,60,180,320,450],houseCost:50},
  {i:4,type:T.TAX,name:'Income Tax',amount:200},
  {i:5,type:T.RAILROAD,name:'Kingâ€™s Cross Station',price:200},
  {i:6,type:T.PROPERTY,name:'The Angel Islington',group:'lightblue',color:'lightblue',price:100,rent:[6,30,90,270,400,550],houseCost:50},
  {i:7,type:T.CHANCE,name:'Chance'},
  {i:8,type:T.PROPERTY,name:'Euston Road',group:'lightblue',color:'lightblue',price:100,rent:[6,30,90,270,400,550],houseCost:50},
  {i:9,type:T.PROPERTY,name:'Pentonville Road',group:'lightblue',color:'lightblue',price:120,rent:[8,40,100,300,450,600],houseCost:50},
  {i:10,type:T.JAIL,name:'Jail / Just Visiting'},
  {i:11,type:T.PROPERTY,name:'Pall Mall',group:'magenta',color:'magenta',price:140,rent:[10,50,150,450,625,750],houseCost:100},
  {i:12,type:T.UTILITY,name:'Electric Company',price:150},
  {i:13,type:T.PROPERTY,name:'Whitehall',group:'magenta',color:'magenta',price:140,rent:[10,50,150,450,625,750],houseCost:100},
  {i:14,type:T.PROPERTY,name:'Northumberland Avenue',group:'magenta',color:'magenta',price:160,rent:[12,60,180,500,700,900],houseCost:100},
  {i:15,type:T.RAILROAD,name:'Marylebone Station',price:200},
  {i:16,type:T.PROPERTY,name:'Bow Street',group:'orange',color:'orange',price:180,rent:[14,70,200,550,750,950],houseCost:100},
  {i:17,type:T.CHEST,name:'Community Chest'},
  {i:18,type:T.PROPERTY,name:'Marlborough Street',group:'orange',color:'orange',price:180,rent:[14,70,200,550,750,950],houseCost:100},
  {i:19,type:T.PROPERTY,name:'Vine Street',group:'orange',color:'orange',price:200,rent:[16,80,220,600,800,1000],houseCost:100},
  {i:20,type:T.PARK,name:'Free Parking'},
  {i:21,type:T.PROPERTY,name:'Strand',group:'red',color:'red',price:220,rent:[18,90,250,700,875,1050],houseCost:150},
  {i:22,type:T.CHANCE,name:'Chance'},
  {i:23,type:T.PROPERTY,name:'Fleet Street',group:'red',color:'red',price:220,rent:[18,90,250,700,875,1050],houseCost:150},
  {i:24,type:T.PROPERTY,name:'Trafalgar Square',group:'red',color:'red',price:240,rent:[20,100,300,750,925,1100],houseCost:150},
  {i:25,type:T.RAILROAD,name:'Fenchurch St. Station',price:200},
  {i:26,type:T.PROPERTY,name:'Leicester Square',group:'yellow',color:'yellow',price:260,rent:[22,110,330,800,975,1150],houseCost:150},
  {i:27,type:T.PROPERTY,name:'Coventry Street',group:'yellow',color:'yellow',price:260,rent:[22,110,330,800,975,1150],houseCost:150},
  {i:28,type:T.UTILITY,name:'Water Works',price:150},
  {i:29,type:T.PROPERTY,name:'Piccadilly',group:'yellow',color:'yellow',price:280,rent:[24,120,360,850,1025,1200],houseCost:150},
  {i:30,type:T.GOTOJAIL,name:'Go To Jail'},
  {i:31,type:T.PROPERTY,name:'Regent Street',group:'green',color:'green',price:300,rent:[26,130,390,900,1100,1275],houseCost:200},
  {i:32,type:T.PROPERTY,name:'Oxford Street',group:'green',color:'green',price:300,rent:[26,130,390,900,1100,1275],houseCost:200},
  {i:33,type:T.CHEST,name:'Community Chest'},
  {i:34,type:T.PROPERTY,name:'Bond Street',group:'green',color:'green',price:320,rent:[28,150,450,1000,1200,1400],houseCost:200},
  {i:35,type:T.RAILROAD,name:'Liverpool St. Station',price:200},
  {i:36,type:T.CHANCE,name:'Chance'},
  {i:37,type:T.PROPERTY,name:'Park Lane',group:'darkblue',color:'darkblue',price:350,rent:[35,175,500,1100,1300,1500],houseCost:200},
  {i:38,type:T.TAX,name:'Super Tax',amount:100},
  {i:39,type:T.PROPERTY,name:'Mayfair',group:'darkblue',color:'darkblue',price:400,rent:[50,200,600,1400,1700,2000],houseCost:200},
];
const groupMembers={}; for(const t of tiles){ if(t.group){ (groupMembers[t.group]??=[]).push(t.i);} }

function tileRect(i){ const L=M,R=SIZE-M,T=M,B=SIZE-M; const brx=R-CORNER, bry=B-CORNER; if(i===0) return {x:brx,y:bry,w:CORNER,h:CORNER}; if(i>0 && i<10) return {x:brx-EDGE*i,y:bry,w:EDGE,h:CORNER}; if(i===10) return {x:L,y:bry,w:CORNER,h:CORNER}; if(i>10 && i<20) return {x:L,y:bry-EDGE*(i-10),w:CORNER,h:EDGE}; if(i===20) return {x:L,y:T,w:CORNER,h:CORNER}; if(i>20 && i<30) return {x:L+CORNER+EDGE*(i-21),y:T,w:EDGE,h:CORNER}; if(i===30) return {x:R-CORNER,y:T,w:CORNER,h:CORNER}; if(i>30 && i<40) return {x:R-CORNER,y:T+CORNER+EDGE*(i-31),w:CORNER,h:EDGE}; }
function drawBoardImage(){ const bx=M, by=M, bw=SIZE-2*M, bh=bw; if(!boardReady){ ctx.save(); ctx.fillStyle='#0b1222'; ctx.fillRect(bx,by,bw,bh); ctx.fillStyle='rgba(255,255,255,.65)'; ctx.font='700 20px ui-sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('Loading boardâ€¦', SIZE/2, SIZE/2); ctx.restore(); return; } const iw=boardImg.naturalWidth, ih=boardImg.naturalHeight; const ir=iw/ih; const br=bw/bh; let sx=0, sy=0, sw=iw, sh=ih; if(ir>br){ sw=ih*br; sx=(iw-sw)/2; } else if(ir<br){ sh=iw/br; sy=(ih-sh)/2; } const ROT_Q=1; ctx.save(); ctx.translate(bx+bw/2, by+bh/2); ctx.rotate(ROT_Q*Math.PI/2); ctx.drawImage(boardImg, sx,sy,sw,sh, -bw/2, -bh/2, bw, bh); ctx.restore(); }
function rr(x,y,w,h,r){ const a=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+a,y); ctx.arcTo(x+w,y,x+w,y+h,a); ctx.arcTo(x+w,y+h,x,y+h,a); ctx.arcTo(x,y+h,x,y,a); ctx.arcTo(x,y,x+w,y,a); ctx.closePath(); }

// ==============================
// Decks (UK) â€” definitions in code, order stored in DB
// ==============================
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1)|0); [a[i],a[j]]=[a[j],a[i]]; } return a; }

const chanceCards = [
  {id:'C_ADV_GO', text:'Advance to GO (Collect Â£200)', act: async(pid)=>{ await moveTo(pid,0,true); }},
  {id:'C_GO_JAIL', text:'Go to Jail. Go directly to Jail. Do not pass GO, do not collect Â£200.', act: async(pid)=>{ await goToJail(pid); }},
  {id:'C_BACK3', text:'Go back 3 spaces.', act: async(pid)=>{ await moveRel(pid,-3); }},
  {id:'C_NEAR_STN', text:'Advance to the nearest Station. If owned, pay owner twice the rent.', act: async(pid)=>{ await advanceToNearestStation(pid, true); }},
  {id:'C_NEAR_UTIL', text:'Advance to the nearest Utility. If owned, throw dice and pay 10Ã— the amount thrown.', act: async(pid)=>{ await advanceToNearestUtility(pid); }},
  {id:'C_BANK_DIV', text:'Bank pays you dividend of Â£50.', act: async(pid)=>{ await adjustMoney(pid,50); }},
  {id:'C_REPAIRS', text:'Make general repairs on all your property: For each house pay Â£25, For each hotel Â£100.', act: async(pid)=>{ await repairs(pid,25,100); }},
  {id:'C_ADV_TRAFSQ', text:'Advance to Trafalgar Square. If you pass GO, collect Â£200.', act: async(pid)=>{ await moveTo(pid,24,true); }},
  {id:'C_ADV_MAYFAIR', text:'Advance to Mayfair.', act: async(pid)=>{ await moveTo(pid,39,true); }},
  {id:'C_GET_OUT', text:'Get Out of Jail Free â€” keep this card until needed.', act: async(pid)=>{ await giveGOOJF(pid,'chance'); }}
];

const chestCards = [
  {id:'H_ADV_GO', text:'Advance to GO (Collect Â£200).', act: async(pid)=>{ await moveTo(pid,0,true); }},
  {id:'H_BANK_ERR', text:'Bank error in your favour â€” Collect Â£200.', act: async(pid)=>{ await adjustMoney(pid,200); }},
  {id:'H_DOCTOR', text:"Doctor's fees â€” Pay Â£50.", act: async(pid)=>{ await adjustMoney(pid,-50); }},
  {id:'H_STOCK', text:'From sale of stock you get Â£50.', act: async(pid)=>{ await adjustMoney(pid,50); }},
  {id:'H_GO_JAIL', text:'Go to Jail. Go directly to jail, do not pass GO, do not collect Â£200.', act: async(pid)=>{ await goToJail(pid); }},
  {id:'H_GET_OUT', text:'Get Out of Jail Free â€” keep this card until needed.', act: async(pid)=>{ await giveGOOJF(pid,'chest'); }},
  {id:'H_SCHOOL_FEES', text:'Pay school fees of Â£50.', act: async(pid)=>{ await adjustMoney(pid,-50); }},
  {id:'H_INCOME_TAX_REFUND', text:'Income tax refund â€” Collect Â£20.', act: async(pid)=>{ await adjustMoney(pid,20); }},
  {id:'H_BIRTHDAY', text:"It is your birthday â€” Collect Â£10 from every player.", act: async(pid)=>{ await birthday(pid,10); }}
];

// ==============================
// Live game state
// ==============================
let roomRefs = { root:null, players:null, board:null, turn:null, events:null, decks:null };
let game = { players:{}, board:{ owners:[], mortgaged:[], houses:[] }, turn:null, decks:{ chance:[], chest:[] } };

async function startGameUI(room){ // switch screens
  $('#screenLobby').classList.add('hidden');
  $('#screenGame').classList.remove('hidden');
  roomRefs.root = ref(db, `rooms/${room}`);
  roomRefs.players = child(roomRefs.root, 'players');
  roomRefs.board = child(roomRefs.root, 'board');
  roomRefs.turn = child(roomRefs.root, 'turn');
  roomRefs.events = child(roomRefs.root, 'events');
  roomRefs.decks = child(roomRefs.root, 'decks');

  onValue(roomRefs.players, snap=>{ game.players = snap.val()||{}; refreshSidebar(); drawBoard(); });
  onValue(roomRefs.board, snap=>{ game.board = snap.val()||{owners:[],mortgaged:[],houses:[]}; drawBoard(); });
  onValue(roomRefs.turn, snap=>{ game.turn = snap.val(); updateTurnUI(); drawBoard(); });
  onValue(roomRefs.decks, snap=>{ game.decks = snap.val()||{chance:[],chest:[]}; });
  onValue(roomRefs.events, snap=>{ const ev=snap.val(); if(!ev) return; if(ev.type==='card'){ showCard(ev.payload); } });

  $('#btnRoll').onclick = onRoll;
  $('#btnEnd').onclick = onEndTurn;
  $('#btnBuy').onclick = onBuy;
  $('#cardOk').onclick = closeCard;

  drawBoard();
}

function closeCard(){
  document.getElementById('card').style.display = 'none';
  if(roomRefs?.events && me?.isHost){ update(roomRefs.events, { type:null, payload:null }); }
}

// ==============================
// Helpers â€” money, movement, decks
// ==============================
function r6(){ return (Math.random()*6|0)+1; }

async function adjustMoney(pid, delta){ const p=game.players[pid]; if(!p) return; await update(child(roomRefs.players,pid), { cash: (p.cash||0)+delta }); }

async function moveTo(pid, dest, collectGo=true){ const p=game.players[pid]; if(!p) return; const cur=p.pos||0; let add=0; if(collectGo && (dest<cur)) add+=200; await update(child(roomRefs.players,pid), { pos: dest }); if(add) await adjustMoney(pid, add); await landOn(pid, true); }
async function moveRel(pid, d){ const p=game.players[pid]; const cur=p.pos||0; const dest=((cur+d)%40+40)%40; await moveTo(pid, dest, d>0 && dest<cur); }
async function goToJail(pid){ await update(child(roomRefs.players,pid), { pos:10, inJail:true, jailTurns:0 }); await update(roomRefs.events, { type:'card', payload:{ kind:'Jail', name:'Go To Jail', text:'Go directly to jail.' } }); }
async function giveGOOJF(pid, deck){ const p=game.players[pid]; await update(child(roomRefs.players,pid), { goojf: (p.goojf||0)+1 }); }
async function repairs(pid, perHouse, perHotel){ const counts=countHousesHotels(pid); const amt = counts.houses*perHouse + counts.hotels*perHotel; if(amt>0) await adjustMoney(pid,-amt); }
async function birthday(pid, per){ for(const [otherId,o] of Object.entries(game.players)){ if(otherId===pid) continue; await adjustMoney(otherId,-per); await adjustMoney(pid, per); } }

function countHousesHotels(pid){ const owners=game.board.owners||[]; const hs=game.board.houses||[]; let houses=0, hotels=0; for(let i=0;i<40;i++){ if(owners[i]===pid){ const n=hs[i]||0; if(n===5) hotels++; else houses+=n; } } return {houses,hotels}; }

function nearest(from, arr){ for(let k=1;k<40;k++){ const i=(from+k)%40; if(arr.includes(i)) return i; } return from; }
async function advanceToNearestStation(pid, doubleRent){ const p=game.players[pid]; const cur=p.pos||0; const dest=nearest(cur,[5,15,25,35]); const passed= dest<cur; await moveTo(pid,dest,passed); const owners=game.board.owners||[]; const owner=owners[dest]; if(owner!=null && owner!==pid){ const base=railroadRent(owner); const rent = doubleRent? base*2 : base; await pay(pid, owner, rent); } }
async function advanceToNearestUtility(pid){ const p=game.players[pid]; const cur=p.pos||0; const dest=nearest(cur,[12,28]); const passed= dest<cur; await moveTo(pid,dest,passed); const owners=game.board.owners||[]; const owner=owners[dest]; if(owner!=null && owner!==pid){ const dice=r6()+r6(); const rent=10*dice; await pay(pid, owner, rent); await update(roomRefs.events,{type:'card', payload:{kind:'Chance', name:'Nearest Utility', text:`You rolled ${dice}. Pay Â£${rent}.`}}); } }

async function deckDraw(kind){ const dRef = child(roomRefs.root, `decks/${kind}`); let drawn=null; const res = await runTransaction(dRef, (arr)=>{ if(!Array.isArray(arr) || arr.length===0) return arr; drawn=arr[0]; const rest=arr.slice(1); return [...rest, drawn]; }); if(!res || !res.committed) return null; return drawn; }

// ==============================
// Start game (host): init board + decks + turn
// ==============================
$('#btnStart').onclick = async ()=>{
  if(!me.isHost) return;
  const r=ref(db, `rooms/${me.room}`);
  const playersSnap = await get(child(r,'players')); const players=playersSnap.val()||{}; const order = Object.keys(players); // join order
  const owners = new Array(40).fill(null);
  const mortgaged = new Array(40).fill(false);
  const houses = new Array(40).fill(0);
  const turn = { order, currentIndex:0, current: order[0], rolled:false, dice:[0,0], lastDiceSum:0, extraRoll:false };
  const decks = { chance: shuffle(chanceCards.map((_,i)=>i)), chest: shuffle(chestCards.map((_,i)=>i)) };
  await update(r, { meta:{ hostId:me.playerId, maxPlayers: Object.keys(players).length, state:'playing', startedAt: serverTimestamp() }, board:{ owners, mortgaged, houses }, turn, decks });
};

// ==============================
// Rendering (board + tokens + markers)
// ==============================
function refreshSidebar(){ const list=$('#players'); if(!list) return; list.innerHTML=''; const order = game.turn?.order || Object.keys(game.players); order.forEach(pid=>{ const p=game.players[pid]; if(!p) return; const r1=document.createElement('div'); const r2=document.createElement('div'); r1.textContent=p.name; r2.textContent=`$${p.cash??1500}`; r2.className='money mono'; r1.style.display='flex'; r1.style.alignItems='center'; r1.style.gap='8px'; const dot=document.createElement('span'); dot.style.width='10px'; dot.style.height='10px'; dot.style.borderRadius='999px'; dot.style.display='inline-block'; dot.style.background=p.color; r1.prepend(dot); list.append(r1,r2); }); }

function drawTokens(){ if(!game.players) return; const order = game.turn?.order || Object.keys(game.players); let idx=0; for(const pid of order){ const p=game.players[pid]; if(!p) continue; const r=tileRect(p.pos||0); const offs=[[-16,-16],[16,-16],[-16,16],[16,16]][idx%4]; const cx=r.x+r.w/2+offs[0], cy=r.y+r.h/2+offs[1]; ctx.beginPath(); ctx.arc(cx,cy,12,0,Math.PI*2); ctx.fillStyle=p.color; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.stroke(); ctx.font='10px ui-sans-serif'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.fillStyle='#111'; ctx.fillText(p.name.slice(0,4).toUpperCase(), cx, cy+12); idx++; }
}

function drawBoard(){ ctx.clearRect(0,0,SIZE,SIZE); drawBoardImage(); if(game.turn){ const pid = game.turn.current || game.turn.order[game.turn.currentIndex]; const p=game.players[pid]; if(p){ const r=tileRect(p.pos||0); ctx.save(); ctx.fillStyle='rgba(255,255,0,.12)'; rr(r.x+4,r.y+4,r.w-8,r.h-8,8); ctx.fill(); ctx.restore(); } } const owners=game.board.owners||[]; const houses=game.board.houses||[]; for(let i=0;i<40;i++){ const r=tileRect(i); if(owners[i]){ const o=game.players[owners[i]]; if(o){ ctx.save(); ctx.translate(r.x+r.w/2, r.y+12); ctx.fillStyle=o.color; ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(-10,0); ctx.lineTo(10,0); ctx.closePath(); ctx.fill(); ctx.fillRect(-9,0,18,10); ctx.restore(); } } const n=houses[i]||0; if(n>0){ const pad=4,size=10; if(i>0&&i<10){ const y=r.y+6; for(let k=0;k<(n===5?1:n);k++){ ctx.fillStyle=(n===5?'#d93a3a':'#1fb25a'); ctx.fillRect(r.x+8+k*(size+pad), y, size, size);} if(n===5){ ctx.fillRect(r.x+8, y, size*2+pad, size+3);} } else if(i>20&&i<30){ const y=r.y+r.h-16; for(let k=0;k<(n===5?1:n);k++){ ctx.fillStyle=(n===5?'#d93a3a':'#1fb25a'); ctx.fillRect(r.x+8+k*(size+pad), y, size, size);} if(n===5){ ctx.fillRect(r.x+8, y, size*2+pad, size+3);} } else if(i>10&&i<20){ const x=r.x+r.w-16; for(let k=0;k<(n===5?1:n);k++){ ctx.fillStyle=(n===5?'#d93a3a':'#1fb25a'); ctx.fillRect(x, r.y+8+k*(size+pad), size, size);} if(n===5){ ctx.fillRect(x, r.y+8, size+3, size*2+pad);} } else if(i>30&&i<40){ const x=r.x+6; for(let k=0;k<(n===5?1:n);k++){ ctx.fillStyle=(n===5?'#d93a3a':'#1fb25a'); ctx.fillRect(x, r.y+8+k*(size+pad), size, size);} if(n===5){ ctx.fillRect(x, r.y+8, size+3, size*2+pad);} } } } drawTokens(); }

// ==============================
// Turn UI + actions
// ==============================
function updateTurnUI(){ if(!game.turn) return; const pid = game.turn.current || game.turn.order[game.turn.currentIndex]; const p = game.players[pid]; $('#turnName').textContent = p? p.name : '-'; const isMyTurn = pid===me.playerId; $('#btnRoll').disabled = !isMyTurn || !!game.turn.rolled; $('#btnEnd').disabled  = !isMyTurn || !game.turn.rolled; $('#btnBuy').disabled  = true; $('#diceFace').textContent = `ðŸŽ² ${game.turn.dice?.[0]||0} + ${game.turn.dice?.[1]||0} = ${game.turn.lastDiceSum||0}`; }

async function onRoll(){ if(!game.turn) return; const rollRef = roomRefs.turn; const d1 = (Math.random()*6|0)+1; const d2 = (Math.random()*6|0)+1; const res = await runTransaction(rollRef, (t)=>{ if(!t) return t; const pid = t.current || t.order[t.currentIndex]; if(pid!==me.playerId) return t; if(t.rolled) return t; t.dice=[d1,d2]; t.lastDiceSum=d1+d2; t.rolled=true; return t; }); if(!res || !res.committed) return; const val=res.snapshot.val(); const pid2 = val.current || val.order[val.currentIndex]; await moveSteps(pid2, val.lastDiceSum||0); }

async function onEndTurn(){ if(!game.turn) return; await runTransaction(roomRefs.turn, (t)=>{ if(!t) return t; const pid=t.current || t.order[t.currentIndex]; if(pid!==me.playerId) return t; if(!t.rolled) return t; const next=(t.currentIndex+1)%t.order.length; t.currentIndex=next; t.current=t.order[next]; t.rolled=false; t.dice=[0,0]; t.lastDiceSum=0; return t; }); $('#btnBuy').disabled=true; }

async function moveSteps(pid, steps){ const pos=(game.players[pid]?.pos||0); if(steps<=0) return landOn(pid); const next=(pos+1)%40; await update(child(roomRefs.players,pid), { pos: next }); if(next===0){ const cash=(game.players[pid]?.cash||1500)+200; await update(child(roomRefs.players,pid), { cash }); log(`${game.players[pid]?.name||'Player'} passes GO and collects $200.`); } drawBoard(); setTimeout(()=>moveSteps(pid, steps-1), 220); }

function tileAt(i){ return tiles[i]; }
function railroadRent(ownerId){ const owners=game.board.owners||[]; let c=0; for(const j of [5,15,25,35]) if(owners[j]===ownerId) c++; return c? 25*Math.pow(2,c-1) : 0; }
function utilityMult(ownerId){ const owners=game.board.owners||[]; let c=0; for(const j of [12,28]) if(owners[j]===ownerId) c++; return c>=2?10:4; }
function ownsFullSet(pid, group){ const owners=game.board.owners||[]; const mem=groupMembers[group]||[]; return mem.length && mem.every(i=>owners[i]===pid); }

async function landOn(pid, fromCard=false){ const p=game.players[pid]; const t=tileAt(p.pos); if(!t) return; if(t.type===T.PROPERTY || t.type===T.RAILROAD || t.type===T.UTILITY){ const ownersArr=game.board.owners||[]; const owner=ownersArr[t.i]; if(owner==null){ if(pid===me.playerId) $('#btnBuy').disabled=false; log(`${p.name} may buy <b>${t.name}</b> for $${t.price}.`); } else if(owner!==pid){ let rent=0; if(t.type===T.PROPERTY) rent=calcRent(t.i); else if(t.type===T.RAILROAD) rent=railroadRent(owner); else if(t.type===T.UTILITY) rent=utilityMult(owner)*(game.turn?.lastDiceSum||0); await pay(pid, owner, rent); log(`${p.name} pays $${rent} to ${game.players[owner].name} for ${t.name}.`); } }
  else if(t.type===T.CHANCE){ await doChance(pid); }
  else if(t.type===T.CHEST){ await doChest(pid); }
  else if(t.type===T.GOTOJAIL){ await goToJail(pid); }
}

function calcRent(idx){ const owners=game.board.owners||[]; const t=tiles[idx]; if(t.type===T.PROPERTY){ const houses=(game.board.houses||[])[idx]||0; if(houses>0) return t.rent[houses]; let base=t.rent[0]; if(ownsFullSet(owners[idx], t.group)) base*=2; return base; } if(t.type===T.RAILROAD){ return railroadRent(owners[idx]); } if(t.type===T.UTILITY){ return utilityMult(owners[idx]) * (game.turn?.lastDiceSum||0); } return 0; }

async function pay(fromPid, toPid, amt){ const from=game.players[fromPid]; const to=game.players[toPid]; const fCash=(from.cash||0)-amt; const tCash=(to.cash||0)+amt; await update(child(roomRefs.players, fromPid), { cash: Math.max(0,fCash) }); await update(child(roomRefs.players, toPid), { cash: tCash }); }

async function onBuy(){
  const pid=me.playerId; if(!pid) return;
  const p=game.players[pid]; if(!p) return;
  const t=tiles[p.pos];
  const ownersArr=game.board.owners||[];
  if(ownersArr[t.i]!=null) return;
  const price=t.price||0;
  if((p.cash||0) < price) { log(`<b>Not enough cash</b> to buy ${t.name}.`); return; }
  ownersArr[t.i]=pid;
  await update(roomRefs.board, { owners: ownersArr });
  await update(child(roomRefs.players,pid), { cash: (p.cash||0) - price });
  log(`<b>${p.name}</b> bought <b>${t.name}</b> for Â£${price}.`);
  await update(roomRefs.events, { type:'card', payload:{ kind:'deed', name:t.name, html: deedHTML(t) } });
}

// ==============================
// Chance / Chest â€” draw & apply
// ==============================
async function doChance(pid){
  const idx = await deckDraw('chance'); if(idx==null) return;
  const card = chanceCards[idx];
  log(`<b>Chance:</b> ${card.text}`);
 o;gap:6px;margin-top:8px">
    <span>Rent (site only)</span><span>Â£${t.rent[0]}</span>
    <span>With 1 House</span><span>Â£${t.rent[1]}</span>
    <span>With 2 Houses</span><span>Â£${t.rent[2]}</span>
    <span>With 3 Houses</span><span>Â£${t.rent[3]}</span>
    <span>With 4 Houses</span><span>Â£${t.rent[4]}</span>
    <span>With HOTEL</span><span>Â£${t.rent[5]}</span>
  </div>
  <div style="margin-top:8px;font-size:13px">Houses cost Â£${t.houseCost} each â€¢ Mortgage Â£${t.price/2}</div>
</div>`; } if(t.type===T.RAILROAD){ return `<div style="text-align:left;color:#111">
  <div style="font-weight:800;text-align:center">${t.name}</div>
  <div class="mono" style="display:grid;grid-template-columns:1fr auto;gap:6px;margin-top:8px">
    <span>Rent</span><span>Â£25</span>
    <span>If 2 Stations owned</span><span>Â£50</span>
    <span>If 3 Stations owned</span><span>Â£100</span>
    <span>If 4 Stations owned</span><span>Â£200</span>
  </div>
  <div style="margin-top:8px;font-size:13px">Price Â£200 â€¢ Mortgage Â£100</div>
</div>`; } if(t.type===T.UTILITY){ return `<div style="text-align:left;color:#111">
  <div style="font-weight:800;text-align:center">${t.name}</div>
  <div class="mono" style="display:grid;grid-template-columns:1fr auto;gap:6px;margin-top:8px">
    <span>Rent (if one Utility owned)</span><span>4Ã— dice</span>
    <span>Rent (if both Utilities owned)</span><span>10Ã— dice</span>
  </div>
  <div style="margin-top:8px;font-size:13px">Price Â£150 â€¢ Mortgage Â£75</div>
</div>`; } return `<div>${t.name}</div>`; }

function showCard({kind,name,text,html}){ const head=$('#cardHead'), body=$('#cardBody'); head.textContent = name || kind; head.style.background = kind==='Chance'? '#ff9b55' : (kind==='Chest'? '#6bd4de' : '#ffd166'); $('#card').style.display='flex'; body.innerHTML = html || (text || ''); }
$('#cardOk').onclick = ()=>{ document.getElementById('card').style.display='none'; if(roomRefs?.events && me?.isHost){ update(roomRefs.events, { type:null, payload:null }); } };

// Click to open deed
canvas.addEventListener('click', (ev)=>{
  const rect=canvas.getBoundingClientRect();
  const x=(ev.clientX-rect.left)*canvas.width/rect.width; const y=(ev.clientY-rect.top)*canvas.height/rect.height;
  for(let i=0;i<40;i++){
    const r=tileRect(i);
    if(x>=r.x&&x<=r.x+r.w&&y>=r.y&&y<=r.y+r.h){
      const t=tiles[i];
      if([T.PROPERTY,T.RAILROAD,T.UTILITY].includes(t.type)){
        showCard({kind:'deed', name:t.name, html:deedHTML(t)});
      } else if(t.type===T.CHANCE){
        showCard({kind:'Chance', name:'Chance', text:'Draw a Chance card by landing on it.'});
      } else if(t.type===T.CHEST){
        showCard({kind:'Chest', name:'Community Chest', text:'Draw a Community Chest card by landing on it.'});
      }
      break;
    }
  }
});
      } else if(t.type===T.CHANCE){
        showCard({kind:'Chance', name:'Chance', text:'Draw a Chance card by landing on it.'});
      } else if(t.type===T.CHEST){
        showCard({kind:'Chest', name:'Community Chest', text:'Draw a Community Chest card by landing on it.'});
      }
      break;
    }
  }
}); const x=(ev.clientX-rect.left)*canvas.width/rect.width; const y=(ev.clientY-rect.top)*canvas.height/rect.height; for(let i=0;i<40;i++){ const r=tileRect(i); if(x>=r.x&&x<=r.x+r.w&&y>=r.y&&y<=r.y+r.h){ const t=tiles[i]; if([T.PROPERTY,T.RAILROAD,T.UTILITY].includes(t.type)){ showCard({kind:'deed', name:t.name, html:deedHTML(t)}); } break; } } });

// ==============================
// Minimal self-tests (donâ€™t affect gameplay)
// ==============================
(function(){
  try {
    console.assert(tiles.length === 40, 'There should be 40 tiles');
    [0, 1, 10, 20, 30, 39].forEach(i => {
      const r = tileRect(i);
      console.assert(r && 'x' in r && 'w' in r, 'tileRect ok ' + i);
    });
  } catch (e) {
    console.warn('Self-tests failed', e);
  }
})();
</script>
</body>
</html>

